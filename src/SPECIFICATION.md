## Part 1. Обход графа в глубину и в ширину

Реализуй библиотеку s21_graph:
* Библиотека должна быть разработана языке C.
* Код библиотеки должен находиться в папке src в ветке develop.
* При написании программы используй стандартный для выбранного языка стиль написания кода.
* Оформи решение как статическую библиотеку (s21_graph).
* Библиотека должна быть представлена в виде класса `graph`, который хранит в себе информацию о графе с помощью **матрицы смежности**. Размерность матрицы смежности должна задаваться динамически при инициализации графа (при его загрузке из файла).
* Сборка программы должна быть настроена с помощью Makefile со стандартным набором целей для GNU-программ: all, clean, test, s21_graph.
* Обеспечь полное покрытие unit-тестами методов класса `graph`.
* Класс `graph` должен содержать в себе, по крайней мере, следующие публичные методы:
    + `load_graph_from_file(char *filename)` — загрузка графа из файла в формате матрицы смежности;
    + `export_graph_to_dot(char *filename)` — выгрузка графа в файл в формате dot (см. материалы).

Реализуй библиотеку s21_graph_algorithms:
* Библиотека должна быть разработана на языке C.
* Код библиотеки должен находиться в папке src в ветке develop.
* Оформи решение как статическую библиотеку (s21_graph_algorithms).
* Библиотека должна быть представлена в виде класса `graph_algorithms`, который будет содержать в себе реализацию алгоритмов на графах. При этом сам класс `graph_algorithms` не должен ничего знать о внутреннем представлении графа из класса `graph`. Для взаимодействия с данными графа класс `graph_algorithms` может использовать только публичные методы и свойства, предоставляемые классом `graph`.
* Добавь в Makefile цель s21_graph_algorithms.
* Ообеспечь полное покрытие unit-тестами методов класса `graph_algorithms`.
* Класс `graph_algorithms` должен содержать в себе, по крайней мере, следующие публичные методы:    
    + `depth_first_search(graph *graph, int start_vertex)` — *нерекурентный* поиск в глубину в графе от заданной вершины. Функция должна возвращать массив, содержащий в себе обойдённые вершины в порядке их обхода. При реализации этой функции обязательно используй *самописную* структуру данных **стек**, которую предварительно стоит оформить в виде отдельной статической библиотеки.
    + `breadth_first_search(graph *graph, int start_vertex)` — поиск в ширину в графе от заданной вершины. Функция должна возвращать массив, содержащий в себе обойдённые вершины в порядке их обхода. При реализации этой функции обязательно используй *самописную* структуру данных **очередь**, которую предварительно стоит оформить в виде отдельной статической библиотеки.
* Необходимо адаптировать ранее созданные *самописные* вспомогательные классы `stack` и `queue` (для этого можно переиспользовать своё решение из проекта *CPP2*) и реализовать для них интерфейсы на C. Эти классы должны содержать в себе следующие методы:
    + `stack()` — создание пустого стека;
    + `queue()` — создание пустой очереди;
    + `push(value)` — добавление элемента в стек/очередь;
    + `pop()` — получение элемента из стека/очереди с его последующим удалением из стека/очереди;
    + `top()` — получение элемента из стека без его удаления из стека;
    + `front()` — получение первого элемента из очереди без его удаления из очереди;
    + `back()` — получение последнего элемента из очереди без его удаления из очереди.

*В этом и последующих заданиях считай, что номера вершин начинаются с 1.*

## Part 2. Поиск кратчайших путей в графе

* Добавь в класс `graph_algorithms` два новых метода:
    + `get_shortest_path_between_vertices(graph *graph, int vertex1, int vertex2)` — поиск кратчайшего пути между двумя вершинами в графе с использованием *алгоритма Дейкстры*. Функция принимает на вход номера двух вершин и возвращает численный результат, равный наименьшему расстоянию между ними.
    + `get_shortest_paths_between_all_vertices(graph *graph)` — поиск кратчайших путей между всеми парами вершин в графе с использованием *алгоритма Флойда-Уоршелла*. В качестве результата функция возвращает матрицу кратчайших путей между всеми вершинами графа.

## Part 3. Поиск минимального остовного дерева

* Добавь в класс `graph_algorithms` новый метод:
    + `get_least_spanning_tree(graph *graph)` — поиск наименьшего остовного дерева в графе с помощью *алгоритма Прима*. В качестве результата функция должна возвращать матрицу смежности для минимального остовного дерева.

## Part 4. Задача коммивояжера

* Добавь в класс `graph_algorithms` новый метод:
    + `solve_traveling_salesman_problem(graph *graph)` — решение задачи коммивояжера с помощью *муравьиного алгоритма*. Найди самый выгодный (короткий) маршрут, проходящий через все вершины графа хотя бы по одному разу с последующим возвратом в исходную вершину. В качестве результата функция должна возвращать структуру `tsm_result`, описанную ниже для примера на С:
    ```c
    struct tsm_result {
        int* vertices;    // массив с искомым маршрутом (с порядком обхода вершин)
        double distance;  // длина этого маршрута
    }
    ``` 

*Если при заданном графе решение задачи невозможно, выведи ошибку.*

## Part 5. Консольный интерфейс

* Тебе необходимо написать основную программу, представляющую собой консольное приложение для проверки работоспособности реализованных библиотек s21_graph и s21_graph_algorithms.
* Консольный интерфейс обязательно должен покрывать следующий функционал:
    1. Загрузка исходного графа из файла.
    2. Обход графа в ширину с выводом результата обхода в консоль.
    3. Обход графа в глубину с выводом результата обхода в консоль.
    4. Поиск кратчайшего пути между произвольными двумя вершинами с выводом результата в консоль.
    5. Поиск кратчайших путей между всеми парами вершин в графе с выводом результирующей матрицы в консоль.
    6. Поиск минимального остовного дерева в графе с выводом результирующей матрицы смежности в консоль.
    7. Решение задачи коммивояжера с выводом результирующего маршрута и его длины в консоль.
